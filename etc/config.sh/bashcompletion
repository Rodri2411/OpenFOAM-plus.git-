#----------------------------------*-sh-*--------------------------------------
# Bash completions for OpenFOAM applications

unset -f _filter_opts 2>/dev/null
_filter_opts()
{
    local allOpts=$1
    local applied=$2
    for o in ${allOpts}; do
        [ "${applied/$o/}" == "${applied}" ] && echo $o
    done
}

unset -f _adiabaticFlameT 2>/dev/null
_adiabaticFlameT()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _adiabaticFlameT adiabaticFlameT

unset -f _adjointShapeOptimizationFoam 2>/dev/null
_adjointShapeOptimizationFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _adjointShapeOptimizationFoam adjointShapeOptimizationFoam

unset -f _ansysToFoam 2>/dev/null
_ansysToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _ansysToFoam ansysToFoam

unset -f _applyBoundaryLayer 2>/dev/null
_applyBoundaryLayer()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -ybl "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _applyBoundaryLayer applyBoundaryLayer

unset -f _attachMesh 2>/dev/null
_attachMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _attachMesh attachMesh

unset -f _autoPatch 2>/dev/null
_autoPatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _autoPatch autoPatch

unset -f _blockMesh 2>/dev/null
_blockMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-blockTopology -noClean -noFunctionObjects -sets -srcDoc -doc -help "
    local optsWithArgs="-case -dict -region "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _blockMesh blockMesh

unset -f _boundaryFoam 2>/dev/null
_boundaryFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _boundaryFoam boundaryFoam

unset -f _boxTurb 2>/dev/null
_boxTurb()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _boxTurb boxTurb

unset -f _buoyantBoussinesqPimpleFoam 2>/dev/null
_buoyantBoussinesqPimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _buoyantBoussinesqPimpleFoam buoyantBoussinesqPimpleFoam

unset -f _buoyantBoussinesqSimpleFoam 2>/dev/null
_buoyantBoussinesqSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _buoyantBoussinesqSimpleFoam buoyantBoussinesqSimpleFoam

unset -f _buoyantPimpleFoam 2>/dev/null
_buoyantPimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _buoyantPimpleFoam buoyantPimpleFoam

unset -f _buoyantSimpleFoam 2>/dev/null
_buoyantSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _buoyantSimpleFoam buoyantSimpleFoam

unset -f _cavitatingDyMFoam 2>/dev/null
_cavitatingDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _cavitatingDyMFoam cavitatingDyMFoam

unset -f _cavitatingFoam 2>/dev/null
_cavitatingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _cavitatingFoam cavitatingFoam

unset -f _cfx4ToFoam 2>/dev/null
_cfx4ToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _cfx4ToFoam cfx4ToFoam

unset -f _changeDictionary 2>/dev/null
_changeDictionary()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -disablePatchGroups -enableFunctionEntries -latestTime -literalRE -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -instance -region -roots -subDict -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _changeDictionary changeDictionary

unset -f _checkMesh 2>/dev/null
_checkMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-allGeometry -allTopology -constant -latestTime -meshQuality -newTimes -noFunctionObjects -noTopology -noZero -parallel -writeAllFields -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time -writeFields -writeSets "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _checkMesh checkMesh

unset -f _chemFoam 2>/dev/null
_chemFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _chemFoam chemFoam

unset -f _chemkinToFoam 2>/dev/null
_chemkinToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-newFormat -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _chemkinToFoam chemkinToFoam

unset -f _chtMultiRegionFoam 2>/dev/null
_chtMultiRegionFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _chtMultiRegionFoam chtMultiRegionFoam

unset -f _chtMultiRegionSimpleFoam 2>/dev/null
_chtMultiRegionSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _chtMultiRegionSimpleFoam chtMultiRegionSimpleFoam

unset -f _coalChemistryFoam 2>/dev/null
_coalChemistryFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _coalChemistryFoam coalChemistryFoam

unset -f _coldEngineFoam 2>/dev/null
_coldEngineFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _coldEngineFoam coldEngineFoam

unset -f _collapseEdges 2>/dev/null
_collapseEdges()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-collapseFaces -constant -latestTime -newTimes -noFunctionObjects -noZero -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -collapseFaceSet -decomposeParDict -dict -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _collapseEdges collapseEdges

unset -f _combinePatchFaces 2>/dev/null
_combinePatchFaces()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-meshQuality -noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -concaveAngle -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _combinePatchFaces combinePatchFaces

unset -f _compressibleInterDyMFoam 2>/dev/null
_compressibleInterDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _compressibleInterDyMFoam compressibleInterDyMFoam

unset -f _compressibleInterFoam 2>/dev/null
_compressibleInterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _compressibleInterFoam compressibleInterFoam

unset -f _compressibleMultiphaseInterFoam 2>/dev/null
_compressibleMultiphaseInterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _compressibleMultiphaseInterFoam compressibleMultiphaseInterFoam

unset -f _createBaffles 2>/dev/null
_createBaffles()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _createBaffles createBaffles

unset -f _createExternalCoupledPatchGeometry 2>/dev/null
_createExternalCoupledPatchGeometry()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -commsDir -decomposeParDict -region -regions -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _createExternalCoupledPatchGeometry createExternalCoupledPatchGeometry

unset -f _createPatch 2>/dev/null
_createPatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -writeObj -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _createPatch createPatch

unset -f _createZeroDirectory 2>/dev/null
_createZeroDirectory()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -templateDir "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _createZeroDirectory createZeroDirectory

unset -f _datToFoam 2>/dev/null
_datToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _datToFoam datToFoam

unset -f _decomposePar 2>/dev/null
_decomposePar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-allRegions -cellDist -constant -copyUniform -copyZero -fields -force -ifRequired -latestTime -newTimes -noFunctionObjects -noSets -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _decomposePar decomposePar

unset -f _deformedGeom 2>/dev/null
_deformedGeom()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _deformedGeom deformedGeom

unset -f _dnsFoam 2>/dev/null
_dnsFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _dnsFoam dnsFoam

unset -f _DPMDyMFoam 2>/dev/null
_DPMDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloudName -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _DPMDyMFoam DPMDyMFoam

unset -f _DPMFoam 2>/dev/null
_DPMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _DPMFoam DPMFoam

unset -f _driftFluxFoam 2>/dev/null
_driftFluxFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _driftFluxFoam driftFluxFoam

unset -f _dsmcFoam 2>/dev/null
_dsmcFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _dsmcFoam dsmcFoam

unset -f _dsmcInitialise 2>/dev/null
_dsmcInitialise()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _dsmcInitialise dsmcInitialise

unset -f _electrostaticFoam 2>/dev/null
_electrostaticFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _electrostaticFoam electrostaticFoam

unset -f _engineCompRatio 2>/dev/null
_engineCompRatio()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _engineCompRatio engineCompRatio

unset -f _engineFoam 2>/dev/null
_engineFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _engineFoam engineFoam

unset -f _engineSwirl 2>/dev/null
_engineSwirl()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _engineSwirl engineSwirl

unset -f _equilibriumCO 2>/dev/null
_equilibriumCO()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _equilibriumCO equilibriumCO

unset -f _equilibriumFlameT 2>/dev/null
_equilibriumFlameT()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _equilibriumFlameT equilibriumFlameT

unset -f _extrude2DMesh 2>/dev/null
_extrude2DMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _extrude2DMesh extrude2DMesh

unset -f _extrudeMesh 2>/dev/null
_extrudeMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _extrudeMesh extrudeMesh

unset -f _extrudeToRegionMesh 2>/dev/null
_extrudeToRegionMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _extrudeToRegionMesh extrudeToRegionMesh

unset -f _faceAgglomerate 2>/dev/null
_faceAgglomerate()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _faceAgglomerate faceAgglomerate

unset -f _financialFoam 2>/dev/null
_financialFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _financialFoam financialFoam

unset -f _fireFoam 2>/dev/null
_fireFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _fireFoam fireFoam

unset -f _fireToFoam 2>/dev/null
_fireToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -check -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _fireToFoam fireToFoam

unset -f _flattenMesh 2>/dev/null
_flattenMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _flattenMesh flattenMesh

unset -f _fluent3DMeshToFoam 2>/dev/null
_fluent3DMeshToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-cubit -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -ignoreCellGroups -ignoreFaceGroups -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _fluent3DMeshToFoam fluent3DMeshToFoam

unset -f _fluentMeshToFoam 2>/dev/null
_fluentMeshToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -writeSets -writeZones -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _fluentMeshToFoam fluentMeshToFoam

unset -f _foamDataToFluent 2>/dev/null
_foamDataToFluent()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-latestTime -newTimes -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamDataToFluent foamDataToFluent

unset -f _foamDictionary 2>/dev/null
_foamDictionary()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-disableFunctionEntries -expand -includes -keywords -noFunctionObjects -parallel -remove -value -srcDoc -doc -help "
    local optsWithArgs="-add -case -decomposeParDict -diff -entry -roots -set "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamDictionary foamDictionary

unset -f _foamFormatConvert 2>/dev/null
_foamFormatConvert()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -enableFunctionEntries -latestTime -newTimes -noConstant -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamFormatConvert foamFormatConvert

unset -f _foamHelp 2>/dev/null
_foamHelp()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamHelp foamHelp

unset -f _foamList 2>/dev/null
_foamList()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-compressibleTurbulenceModels -functionObjects -fvOptions -incompressibleTurbulenceModels -noFunctionObjects -registeredSwitches -switches -unset -srcDoc -doc -help "
    local optsWithArgs="-case -scalarBCs -vectorBCs "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamList foamList

unset -f _foamListTimes 2>/dev/null
_foamListTimes()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -processor -rm -withZero -srcDoc -doc -help "
    local optsWithArgs="-case -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamListTimes foamListTimes

unset -f _foamMeshToFluent 2>/dev/null
_foamMeshToFluent()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamMeshToFluent foamMeshToFluent

unset -f _foamToEnsight 2>/dev/null
_foamToEnsight()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -constant -deprecatedOrder -latestTime -newTimes -noFunctionObjects -noLagrangian -noPatches -noZero -nodeValues -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -cellZone -decomposeParDict -faceZones -fields -name -patches -region -roots -time -width "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToEnsight foamToEnsight

unset -f _foamToEnsightParts 2>/dev/null
_foamToEnsightParts()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -constant -latestTime -newTimes -noFunctionObjects -noLagrangian -noMesh -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -index -name -time -width "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToEnsightParts foamToEnsightParts

unset -f _foamToFireMesh 2>/dev/null
_foamToFireMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -constant -latestTime -newTimes -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -scale -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToFireMesh foamToFireMesh

unset -f _foamToGMV 2>/dev/null
_foamToGMV()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToGMV foamToGMV

unset -f _foamToStarMesh 2>/dev/null
_foamToStarMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noBnd -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -scale -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToStarMesh foamToStarMesh

unset -f _foamToSurface 2>/dev/null
_foamToSurface()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -tri -srcDoc -doc -help "
    local optsWithArgs="-case -scale -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToSurface foamToSurface

unset -f _foamToTetDualMesh 2>/dev/null
_foamToTetDualMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -noFunctionObjects -noZero -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToTetDualMesh foamToTetDualMesh

unset -f _foamToVTK 2>/dev/null
_foamToVTK()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-allPatches -ascii -constant -latestTime -nearCellValue -newTimes -noFaceZones -noFunctionObjects -noInternal -noLagrangian -noLinks -noPointValues -noZero -parallel -poly -surfaceFields -useTimeName -srcDoc -doc -help "
    local optsWithArgs="-case -cellSet -decomposeParDict -excludePatches -faceSet -fields -pointSet -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToVTK foamToVTK

unset -f _foamUpgradeCyclics 2>/dev/null
_foamUpgradeCyclics()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -enableFunctionEntries -latestTime -newTimes -noFunctionObjects -noZero -parallel -test -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamUpgradeCyclics foamUpgradeCyclics

unset -f _foamyHexMesh 2>/dev/null
_foamyHexMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-checkGeometry -conformationOnly -noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamyHexMesh foamyHexMesh

unset -f _foamyQuadMesh 2>/dev/null
_foamyQuadMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case -pointsFile "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamyQuadMesh foamyQuadMesh

unset -f _gambitToFoam 2>/dev/null
_gambitToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _gambitToFoam gambitToFoam

unset -f _gmshToFoam 2>/dev/null
_gmshToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-keepOrientation -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -region "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _gmshToFoam gmshToFoam

unset -f _icoFoam 2>/dev/null
_icoFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _icoFoam icoFoam

unset -f _icoUncoupledKinematicParcelDyMFoam 2>/dev/null
_icoUncoupledKinematicParcelDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _icoUncoupledKinematicParcelDyMFoam icoUncoupledKinematicParcelDyMFoam

unset -f _icoUncoupledKinematicParcelFoam 2>/dev/null
_icoUncoupledKinematicParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _icoUncoupledKinematicParcelFoam icoUncoupledKinematicParcelFoam

unset -f _ideasUnvToFoam 2>/dev/null
_ideasUnvToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-dump -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _ideasUnvToFoam ideasUnvToFoam

unset -f _insideCells 2>/dev/null
_insideCells()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _insideCells insideCells

unset -f _interCondensatingEvaporatingFoam 2>/dev/null
_interCondensatingEvaporatingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _interCondensatingEvaporatingFoam interCondensatingEvaporatingFoam

unset -f _interDyMFoam 2>/dev/null
_interDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _interDyMFoam interDyMFoam

unset -f _interFoam 2>/dev/null
_interFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _interFoam interFoam

unset -f _interMixingFoam 2>/dev/null
_interMixingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _interMixingFoam interMixingFoam

unset -f _interPhaseChangeDyMFoam 2>/dev/null
_interPhaseChangeDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _interPhaseChangeDyMFoam interPhaseChangeDyMFoam

unset -f _interPhaseChangeFoam 2>/dev/null
_interPhaseChangeFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _interPhaseChangeFoam interPhaseChangeFoam

unset -f _kivaToFoam 2>/dev/null
_kivaToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -file -version -zHeadMin "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _kivaToFoam kivaToFoam

unset -f _laplacianFoam 2>/dev/null
_laplacianFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _laplacianFoam laplacianFoam

unset -f _magneticFoam 2>/dev/null
_magneticFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noB -noFunctionObjects -noH -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _magneticFoam magneticFoam

unset -f _mapFields 2>/dev/null
_mapFields()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-consistent -noFunctionObjects -parallelSource -parallelTarget -subtract -srcDoc -doc -help "
    local optsWithArgs="-case -mapMethod -sourceDecomposeParDict -sourceRegion -sourceTime -targetDecomposeParDict -targetRegion "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mapFields mapFields

unset -f _mapFieldsPar 2>/dev/null
_mapFieldsPar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-consistent -noFunctionObjects -noLagrangian -parallel -subtract -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -fields -mapMethod -patchMapMethod -roots -sourceRegion -sourceTime -targetRegion "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mapFieldsPar mapFieldsPar

unset -f _mdEquilibrationFoam 2>/dev/null
_mdEquilibrationFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mdEquilibrationFoam mdEquilibrationFoam

unset -f _mdFoam 2>/dev/null
_mdFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mdFoam mdFoam

unset -f _mdInitialise 2>/dev/null
_mdInitialise()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mdInitialise mdInitialise

unset -f _mergeMeshes 2>/dev/null
_mergeMeshes()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-addRegion -case -decomposeParDict -masterRegion -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mergeMeshes mergeMeshes

unset -f _mergeOrSplitBaffles 2>/dev/null
_mergeOrSplitBaffles()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-detectOnly -noFunctionObjects -overwrite -parallel -split -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mergeOrSplitBaffles mergeOrSplitBaffles

unset -f _mhdFoam 2>/dev/null
_mhdFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mhdFoam mhdFoam

unset -f _mirrorMesh 2>/dev/null
_mirrorMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mirrorMesh mirrorMesh

unset -f _mixtureAdiabaticFlameT 2>/dev/null
_mixtureAdiabaticFlameT()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mixtureAdiabaticFlameT mixtureAdiabaticFlameT

unset -f _modifyMesh 2>/dev/null
_modifyMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _modifyMesh modifyMesh

unset -f _moveDynamicMesh 2>/dev/null
_moveDynamicMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-checkAMI -noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _moveDynamicMesh moveDynamicMesh

unset -f _moveEngineMesh 2>/dev/null
_moveEngineMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _moveEngineMesh moveEngineMesh

unset -f _moveMesh 2>/dev/null
_moveMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _moveMesh moveMesh

unset -f _MPPICDyMFoam 2>/dev/null
_MPPICDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloudName -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _MPPICDyMFoam MPPICDyMFoam

unset -f _MPPICFoam 2>/dev/null
_MPPICFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _MPPICFoam MPPICFoam

unset -f _MPPICInterFoam 2>/dev/null
_MPPICInterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _MPPICInterFoam MPPICInterFoam

unset -f _mshToFoam 2>/dev/null
_mshToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-hex -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mshToFoam mshToFoam

unset -f _multiphaseEulerFoam 2>/dev/null
_multiphaseEulerFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _multiphaseEulerFoam multiphaseEulerFoam

unset -f _multiphaseInterDyMFoam 2>/dev/null
_multiphaseInterDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _multiphaseInterDyMFoam multiphaseInterDyMFoam

unset -f _multiphaseInterFoam 2>/dev/null
_multiphaseInterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _multiphaseInterFoam multiphaseInterFoam

unset -f _netgenNeutralToFoam 2>/dev/null
_netgenNeutralToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _netgenNeutralToFoam netgenNeutralToFoam

unset -f _noise 2>/dev/null
_noise()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _noise noise

unset -f _nonNewtonianIcoFoam 2>/dev/null
_nonNewtonianIcoFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _nonNewtonianIcoFoam nonNewtonianIcoFoam

unset -f _objToVTK 2>/dev/null
_objToVTK()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _objToVTK objToVTK

unset -f _orientFaceZone 2>/dev/null
_orientFaceZone()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _orientFaceZone orientFaceZone

unset -f _particleTracks 2>/dev/null
_particleTracks()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _particleTracks particleTracks

unset -f _patchSummary 2>/dev/null
_patchSummary()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -expand -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _patchSummary patchSummary

unset -f _pdfPlot 2>/dev/null
_pdfPlot()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _pdfPlot pdfPlot

unset -f _PDRFoam 2>/dev/null
_PDRFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _PDRFoam PDRFoam

unset -f _PDRMesh 2>/dev/null
_PDRMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _PDRMesh PDRMesh

unset -f _pimpleDyMFoam 2>/dev/null
_pimpleDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _pimpleDyMFoam pimpleDyMFoam

unset -f _pimpleFoam 2>/dev/null
_pimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _pimpleFoam pimpleFoam

unset -f _pisoFoam 2>/dev/null
_pisoFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _pisoFoam pisoFoam

unset -f _plot3dToFoam 2>/dev/null
_plot3dToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noBlank -noFunctionObjects -singleBlock -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _plot3dToFoam plot3dToFoam

unset -f _polyDualMesh 2>/dev/null
_polyDualMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-concaveMultiCells -doNotPreserveFaceZones -noFunctionObjects -overwrite -splitAllFaces -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _polyDualMesh polyDualMesh

unset -f _porousSimpleFoam 2>/dev/null
_porousSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _porousSimpleFoam porousSimpleFoam

unset -f _postChannel 2>/dev/null
_postChannel()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _postChannel postChannel

unset -f _postProcess 2>/dev/null
_postProcess()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -list -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -field -fields -func -funcs -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _postProcess postProcess

unset -f _potentialFoam 2>/dev/null
_potentialFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-initialiseUBCs -noFunctionObjects -parallel -withFunctionObjects -writePhi -writep -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -pName -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _potentialFoam potentialFoam

unset -f _potentialFreeSurfaceDyMFoam 2>/dev/null
_potentialFreeSurfaceDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _potentialFreeSurfaceDyMFoam potentialFreeSurfaceDyMFoam

unset -f _potentialFreeSurfaceFoam 2>/dev/null
_potentialFreeSurfaceFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _potentialFreeSurfaceFoam potentialFreeSurfaceFoam

unset -f _reactingFoam 2>/dev/null
_reactingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reactingFoam reactingFoam

unset -f _reactingMultiphaseEulerFoam 2>/dev/null
_reactingMultiphaseEulerFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reactingMultiphaseEulerFoam reactingMultiphaseEulerFoam

unset -f _reactingParcelFilmFoam 2>/dev/null
_reactingParcelFilmFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reactingParcelFilmFoam reactingParcelFilmFoam

unset -f _reactingParcelFoam 2>/dev/null
_reactingParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reactingParcelFoam reactingParcelFoam

unset -f _reactingTwoPhaseEulerFoam 2>/dev/null
_reactingTwoPhaseEulerFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reactingTwoPhaseEulerFoam reactingTwoPhaseEulerFoam

unset -f _reconstructPar 2>/dev/null
_reconstructPar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-allRegions -constant -latestTime -newTimes -noFields -noFunctionObjects -noLagrangian -noSets -noZero -withZero -srcDoc -doc -help "
    local optsWithArgs="-case -fields -lagrangianFields -region -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reconstructPar reconstructPar

unset -f _reconstructParMesh 2>/dev/null
_reconstructParMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-cellDist -constant -fullMatch -latestTime -newTimes -noFunctionObjects -noZero -withZero -srcDoc -doc -help "
    local optsWithArgs="-case -mergeTol -region -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reconstructParMesh reconstructParMesh

unset -f _redistributePar 2>/dev/null
_redistributePar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-cellDist -constant -decompose -latestTime -newTimes -noFunctionObjects -noZero -overwrite -parallel -reconstruct -withZero -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -mergeTol -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _redistributePar redistributePar

unset -f _refineHexMesh 2>/dev/null
_refineHexMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-minSet -noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _refineHexMesh refineHexMesh

unset -f _refinementLevel 2>/dev/null
_refinementLevel()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -readLevel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _refinementLevel refinementLevel

unset -f _refineMesh 2>/dev/null
_refineMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-all -noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _refineMesh refineMesh

unset -f _refineWallLayer 2>/dev/null
_refineWallLayer()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -useSet "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _refineWallLayer refineWallLayer

unset -f _removeFaces 2>/dev/null
_removeFaces()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _removeFaces removeFaces

unset -f _renumberMesh 2>/dev/null
_renumberMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -frontWidth -latestTime -noFunctionObjects -noZero -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _renumberMesh renumberMesh

unset -f _rhoCentralDyMFoam 2>/dev/null
_rhoCentralDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoCentralDyMFoam rhoCentralDyMFoam

unset -f _rhoCentralFoam 2>/dev/null
_rhoCentralFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoCentralFoam rhoCentralFoam

unset -f _rhoPimpleDyMFoam 2>/dev/null
_rhoPimpleDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoPimpleDyMFoam rhoPimpleDyMFoam

unset -f _rhoPimpleFoam 2>/dev/null
_rhoPimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoPimpleFoam rhoPimpleFoam

unset -f _rhoPorousSimpleFoam 2>/dev/null
_rhoPorousSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoPorousSimpleFoam rhoPorousSimpleFoam

unset -f _rhoReactingBuoyantFoam 2>/dev/null
_rhoReactingBuoyantFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoReactingBuoyantFoam rhoReactingBuoyantFoam

unset -f _rhoReactingFoam 2>/dev/null
_rhoReactingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoReactingFoam rhoReactingFoam

unset -f _rhoSimpleFoam 2>/dev/null
_rhoSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoSimpleFoam rhoSimpleFoam

unset -f _rotateMesh 2>/dev/null
_rotateMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rotateMesh rotateMesh

unset -f _scalarTransportFoam 2>/dev/null
_scalarTransportFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _scalarTransportFoam scalarTransportFoam

unset -f _selectCells 2>/dev/null
_selectCells()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _selectCells selectCells

unset -f _setFields 2>/dev/null
_setFields()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _setFields setFields

unset -f _setSet 2>/dev/null
_setSet()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -loop -newTimes -noFunctionObjects -noSync -noVTK -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-batch -case -decomposeParDict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _setSet setSet

unset -f _setsToZones 2>/dev/null
_setsToZones()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFlipMap -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _setsToZones setsToZones

unset -f _shallowWaterFoam 2>/dev/null
_shallowWaterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _shallowWaterFoam shallowWaterFoam

unset -f _simpleCoalParcelFoam 2>/dev/null
_simpleCoalParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _simpleCoalParcelFoam simpleCoalParcelFoam

unset -f _simpleFoam 2>/dev/null
_simpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _simpleFoam simpleFoam

unset -f _simpleReactingParcelFoam 2>/dev/null
_simpleReactingParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _simpleReactingParcelFoam simpleReactingParcelFoam

unset -f _singleCellMesh 2>/dev/null
_singleCellMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _singleCellMesh singleCellMesh

unset -f _smapToFoam 2>/dev/null
_smapToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _smapToFoam smapToFoam

unset -f _snappyHexMesh 2>/dev/null
_snappyHexMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-checkGeometry -noFunctionObjects -overwrite -parallel -profiling -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -outFile -patches -region -roots -surfaceSimplify "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _snappyHexMesh snappyHexMesh

unset -f _snappyRefineMesh 2>/dev/null
_snappyRefineMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _snappyRefineMesh snappyRefineMesh

unset -f _solidDisplacementFoam 2>/dev/null
_solidDisplacementFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _solidDisplacementFoam solidDisplacementFoam

unset -f _solidEquilibriumDisplacementFoam 2>/dev/null
_solidEquilibriumDisplacementFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _solidEquilibriumDisplacementFoam solidEquilibriumDisplacementFoam

unset -f _sonicDyMFoam 2>/dev/null
_sonicDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _sonicDyMFoam sonicDyMFoam

unset -f _sonicFoam 2>/dev/null
_sonicFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _sonicFoam sonicFoam

unset -f _sonicLiquidFoam 2>/dev/null
_sonicLiquidFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _sonicLiquidFoam sonicLiquidFoam

unset -f _splitCells 2>/dev/null
_splitCells()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-geometry -noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case -set -tol "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _splitCells splitCells

unset -f _splitMesh 2>/dev/null
_splitMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _splitMesh splitMesh

unset -f _splitMeshRegions 2>/dev/null
_splitMeshRegions()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-cellZones -cellZonesOnly -detectOnly -largestOnly -makeCellZones -noFunctionObjects -overwrite -parallel -prefixRegion -sloppyCellZones -useFaceZones -srcDoc -doc -help "
    local optsWithArgs="-blockedFaces -case -cellZonesFileOnly -decomposeParDict -insidePoint -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _splitMeshRegions splitMeshRegions

unset -f _sprayDyMFoam 2>/dev/null
_sprayDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _sprayDyMFoam sprayDyMFoam

unset -f _sprayEngineFoam 2>/dev/null
_sprayEngineFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _sprayEngineFoam sprayEngineFoam

unset -f _sprayFoam 2>/dev/null
_sprayFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _sprayFoam sprayFoam

unset -f _SRFPimpleFoam 2>/dev/null
_SRFPimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _SRFPimpleFoam SRFPimpleFoam

unset -f _SRFSimpleFoam 2>/dev/null
_SRFSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _SRFSimpleFoam SRFSimpleFoam

unset -f _star4ToFoam 2>/dev/null
_star4ToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -noFunctionObjects -solids -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _star4ToFoam star4ToFoam

unset -f _steadyParticleTracks 2>/dev/null
_steadyParticleTracks()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -dict -region -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _steadyParticleTracks steadyParticleTracks

unset -f _stitchMesh 2>/dev/null
_stitchMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -partial -perfect -srcDoc -doc -help "
    local optsWithArgs="-case -region -toleranceDict "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _stitchMesh stitchMesh

unset -f _subsetMesh 2>/dev/null
_subsetMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -patch -patches -region -resultTime -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _subsetMesh subsetMesh

unset -f _surfaceAdd 2>/dev/null
_surfaceAdd()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-mergeRegions -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -points "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceAdd surfaceAdd

unset -f _surfaceBooleanFeatures 2>/dev/null
_surfaceBooleanFeatures()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-invertedSpace -noFunctionObjects -perturb -surf1Baffle -surf2Baffle -srcDoc -doc -help "
    local optsWithArgs="-case -trim "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceBooleanFeatures surfaceBooleanFeatures

unset -f _surfaceCheck 2>/dev/null
_surfaceCheck()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-blockMesh -checkSelfIntersection -noFunctionObjects -splitNonManifold -verbose -srcDoc -doc -help "
    local optsWithArgs="-case -outputThreshold "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceCheck surfaceCheck

unset -f _surfaceClean 2>/dev/null
_surfaceClean()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noClean -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceClean surfaceClean

unset -f _surfaceCoarsen 2>/dev/null
_surfaceCoarsen()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceCoarsen surfaceCoarsen

unset -f _surfaceConvert 2>/dev/null
_surfaceConvert()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -group -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale -writePrecision "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceConvert surfaceConvert

unset -f _surfaceFeatureConvert 2>/dev/null
_surfaceFeatureConvert()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceFeatureConvert surfaceFeatureConvert

unset -f _surfaceFeatureExtract 2>/dev/null
_surfaceFeatureExtract()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case -dict "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceFeatureExtract surfaceFeatureExtract

unset -f _surfaceFind 2>/dev/null
_surfaceFind()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -x -y -z "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceFind surfaceFind

unset -f _surfaceHookUp 2>/dev/null
_surfaceHookUp()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -dict "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceHookUp surfaceHookUp

unset -f _surfaceInertia 2>/dev/null
_surfaceInertia()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -shellProperties -srcDoc -doc -help "
    local optsWithArgs="-case -density -referencePoint "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceInertia surfaceInertia

unset -f _surfaceInflate 2>/dev/null
_surfaceInflate()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-checkSelfIntersection -debug -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -featureAngle -nSmooth "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceInflate surfaceInflate

unset -f _surfaceLambdaMuSmooth 2>/dev/null
_surfaceLambdaMuSmooth()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-featureFile "

    case ${prev} in

        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceLambdaMuSmooth surfaceLambdaMuSmooth

unset -f _surfaceMeshConvert 2>/dev/null
_surfaceMeshConvert()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -noFunctionObjects -tri -srcDoc -doc -help "
    local optsWithArgs="-case -dict -from -scaleIn -scaleOut -to "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceMeshConvert surfaceMeshConvert

unset -f _surfaceMeshConvertTesting 2>/dev/null
_surfaceMeshConvertTesting()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -noFunctionObjects -orient -stdout -surfMesh -testModify -triFace -triSurface -unsorted -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceMeshConvertTesting surfaceMeshConvertTesting

unset -f _surfaceMeshExport 2>/dev/null
_surfaceMeshExport()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -dict -from -name -scaleIn -scaleOut -to "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceMeshExport surfaceMeshExport

unset -f _surfaceMeshImport 2>/dev/null
_surfaceMeshImport()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -dict -from -name -scaleIn -scaleOut -to "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceMeshImport surfaceMeshImport

unset -f _surfaceMeshInfo 2>/dev/null
_surfaceMeshInfo()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-areas -noFunctionObjects -xml -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceMeshInfo surfaceMeshInfo

unset -f _surfaceMeshTriangulate 2>/dev/null
_surfaceMeshTriangulate()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -excludeProcPatches -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -faceZones -patches -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceMeshTriangulate surfaceMeshTriangulate

unset -f _surfaceOrient 2>/dev/null
_surfaceOrient()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-inside -noFunctionObjects -usePierceTest -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceOrient surfaceOrient

unset -f _surfacePatch 2>/dev/null
_surfacePatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -dict "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfacePatch surfacePatch

unset -f _surfacePointMerge 2>/dev/null
_surfacePointMerge()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfacePointMerge surfacePointMerge

unset -f _surfaceRedistributePar 2>/dev/null
_surfaceRedistributePar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-keepNonMapped -noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceRedistributePar surfaceRedistributePar

unset -f _surfaceRefineRedGreen 2>/dev/null
_surfaceRefineRedGreen()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceRefineRedGreen surfaceRefineRedGreen

unset -f _surfaceSplitByPatch 2>/dev/null
_surfaceSplitByPatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceSplitByPatch surfaceSplitByPatch

unset -f _surfaceSplitByTopology 2>/dev/null
_surfaceSplitByTopology()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs=" "

    case ${prev} in

        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceSplitByTopology surfaceSplitByTopology

unset -f _surfaceSplitNonManifolds 2>/dev/null
_surfaceSplitNonManifolds()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-debug -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceSplitNonManifolds surfaceSplitNonManifolds

unset -f _surfaceSubset 2>/dev/null
_surfaceSubset()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceSubset surfaceSubset

unset -f _surfaceToPatch 2>/dev/null
_surfaceToPatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -faceSet -tol "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceToPatch surfaceToPatch

unset -f _surfaceTransformPoints 2>/dev/null
_surfaceTransformPoints()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -rollPitchYaw -rotate -scale -translate -yawPitchRoll "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceTransformPoints surfaceTransformPoints

unset -f _temporalInterpolate 2>/dev/null
_temporalInterpolate()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -divisions -fields -interpolationType -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _temporalInterpolate temporalInterpolate

unset -f _tetgenToFoam 2>/dev/null
_tetgenToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFaceFile -noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _tetgenToFoam tetgenToFoam

unset -f _thermoFoam 2>/dev/null
_thermoFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _thermoFoam thermoFoam

unset -f _topoSet 2>/dev/null
_topoSet()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noSync -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _topoSet topoSet

unset -f _transformPoints 2>/dev/null
_transformPoints()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -rotateFields -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -rollPitchYaw -roots -rotate -scale -translate -yawPitchRoll "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _transformPoints transformPoints

unset -f _twoLiquidMixingFoam 2>/dev/null
_twoLiquidMixingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _twoLiquidMixingFoam twoLiquidMixingFoam

unset -f _twoPhaseEulerFoam 2>/dev/null
_twoPhaseEulerFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _twoPhaseEulerFoam twoPhaseEulerFoam

unset -f _uncoupledKinematicParcelFoam 2>/dev/null
_uncoupledKinematicParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _uncoupledKinematicParcelFoam uncoupledKinematicParcelFoam

unset -f _viewFactorsGen 2>/dev/null
_viewFactorsGen()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _viewFactorsGen viewFactorsGen

unset -f _vtkUnstructuredToFoam 2>/dev/null
_vtkUnstructuredToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _vtkUnstructuredToFoam vtkUnstructuredToFoam

unset -f _wallFunctionTable 2>/dev/null
_wallFunctionTable()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _wallFunctionTable wallFunctionTable

unset -f _writeMeshObj 2>/dev/null
_writeMeshObj()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -patchEdges -patchFaces -srcDoc -doc -help "
    local optsWithArgs="-case -cell -cellSet -decomposeParDict -face -faceSet -point -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _writeMeshObj writeMeshObj

unset -f _XiDyMFoam 2>/dev/null
_XiDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _XiDyMFoam XiDyMFoam

unset -f _XiFoam 2>/dev/null
_XiFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _XiFoam XiFoam

unset -f _zipUpMesh 2>/dev/null
_zipUpMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _zipUpMesh zipUpMesh


#------------------------------------------------------------------------------
