unset -f _filter_opts
_filter_opts()
{
    local allOpts=$1
    local applied=$2
    for o in ${allOpts}; do
        [ "${applied/$o/}" == "${applied}" ] && echo $o
    done
}

unset -f _adiabaticFlameT
_adiabaticFlameT()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _adiabaticFlameT adiabaticFlameT

unset -f _adjointShapeOptimizationFoam
_adjointShapeOptimizationFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _adjointShapeOptimizationFoam adjointShapeOptimizationFoam

unset -f _ansysToFoam
_ansysToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _ansysToFoam ansysToFoam

unset -f _applyBoundaryLayer
_applyBoundaryLayer()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -ybl "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _applyBoundaryLayer applyBoundaryLayer

unset -f _attachMesh
_attachMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _attachMesh attachMesh

unset -f _autoPatch
_autoPatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _autoPatch autoPatch

unset -f _blockMesh
_blockMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-blockTopology -noClean -noFunctionObjects -sets -srcDoc -doc -help "
    local optsWithArgs="-case -dict -region "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _blockMesh blockMesh

unset -f _boundaryFoam
_boundaryFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _boundaryFoam boundaryFoam

unset -f _boxTurb
_boxTurb()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _boxTurb boxTurb

unset -f _buoyantBoussinesqPimpleFoam
_buoyantBoussinesqPimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _buoyantBoussinesqPimpleFoam buoyantBoussinesqPimpleFoam

unset -f _buoyantBoussinesqSimpleFoam
_buoyantBoussinesqSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _buoyantBoussinesqSimpleFoam buoyantBoussinesqSimpleFoam

unset -f _buoyantPimpleFoam
_buoyantPimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _buoyantPimpleFoam buoyantPimpleFoam

unset -f _buoyantSimpleFoam
_buoyantSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _buoyantSimpleFoam buoyantSimpleFoam

unset -f _cavitatingDyMFoam
_cavitatingDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _cavitatingDyMFoam cavitatingDyMFoam

unset -f _cavitatingFoam
_cavitatingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _cavitatingFoam cavitatingFoam

unset -f _cfx4ToFoam
_cfx4ToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _cfx4ToFoam cfx4ToFoam

unset -f _changeDictionary
_changeDictionary()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -disablePatchGroups -enableFunctionEntries -latestTime -literalRE -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -instance -region -roots -subDict -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _changeDictionary changeDictionary

unset -f _checkMesh
_checkMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-allGeometry -allTopology -constant -latestTime -meshQuality -newTimes -noFunctionObjects -noTopology -noZero -parallel -writeAllFields -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time -writeFields -writeSets "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _checkMesh checkMesh

unset -f _chemFoam
_chemFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _chemFoam chemFoam

unset -f _chemkinToFoam
_chemkinToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-newFormat -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _chemkinToFoam chemkinToFoam

unset -f _chtMultiRegionFoam
_chtMultiRegionFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _chtMultiRegionFoam chtMultiRegionFoam

unset -f _chtMultiRegionSimpleFoam
_chtMultiRegionSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _chtMultiRegionSimpleFoam chtMultiRegionSimpleFoam

unset -f _coalChemistryFoam
_coalChemistryFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _coalChemistryFoam coalChemistryFoam

unset -f _coldEngineFoam
_coldEngineFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _coldEngineFoam coldEngineFoam

unset -f _collapseEdges
_collapseEdges()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-collapseFaces -constant -latestTime -newTimes -noFunctionObjects -noZero -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -collapseFaceSet -decomposeParDict -dict -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _collapseEdges collapseEdges

unset -f _combinePatchFaces
_combinePatchFaces()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-meshQuality -noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -concaveAngle -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _combinePatchFaces combinePatchFaces

unset -f _compressibleInterDyMFoam
_compressibleInterDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _compressibleInterDyMFoam compressibleInterDyMFoam

unset -f _compressibleInterFoam
_compressibleInterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _compressibleInterFoam compressibleInterFoam

unset -f _compressibleMultiphaseInterFoam
_compressibleMultiphaseInterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _compressibleMultiphaseInterFoam compressibleMultiphaseInterFoam

unset -f _createBaffles
_createBaffles()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _createBaffles createBaffles

unset -f _createExternalCoupledPatchGeometry
_createExternalCoupledPatchGeometry()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -commsDir -decomposeParDict -region -regions -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _createExternalCoupledPatchGeometry createExternalCoupledPatchGeometry

unset -f _createPatch
_createPatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -writeObj -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _createPatch createPatch

unset -f _createZeroDirectory
_createZeroDirectory()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -templateDir "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _createZeroDirectory createZeroDirectory

unset -f _datToFoam
_datToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _datToFoam datToFoam

unset -f _decomposePar
_decomposePar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-allRegions -cellDist -constant -copyUniform -copyZero -fields -force -ifRequired -latestTime -newTimes -noFunctionObjects -noSets -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _decomposePar decomposePar

unset -f _deformedGeom
_deformedGeom()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _deformedGeom deformedGeom

unset -f _dnsFoam
_dnsFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _dnsFoam dnsFoam

unset -f _DPMDyMFoam
_DPMDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloudName -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _DPMDyMFoam DPMDyMFoam

unset -f _DPMFoam
_DPMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _DPMFoam DPMFoam

unset -f _driftFluxFoam
_driftFluxFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _driftFluxFoam driftFluxFoam

unset -f _dsmcFoam
_dsmcFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _dsmcFoam dsmcFoam

unset -f _dsmcInitialise
_dsmcInitialise()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _dsmcInitialise dsmcInitialise

unset -f _electrostaticFoam
_electrostaticFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _electrostaticFoam electrostaticFoam

unset -f _engineCompRatio
_engineCompRatio()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _engineCompRatio engineCompRatio

unset -f _engineFoam
_engineFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _engineFoam engineFoam

unset -f _engineSwirl
_engineSwirl()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _engineSwirl engineSwirl

unset -f _equilibriumCO
_equilibriumCO()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _equilibriumCO equilibriumCO

unset -f _equilibriumFlameT
_equilibriumFlameT()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _equilibriumFlameT equilibriumFlameT

unset -f _extrude2DMesh
_extrude2DMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _extrude2DMesh extrude2DMesh

unset -f _extrudeMesh
_extrudeMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _extrudeMesh extrudeMesh

unset -f _extrudeToRegionMesh
_extrudeToRegionMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _extrudeToRegionMesh extrudeToRegionMesh

unset -f _faceAgglomerate
_faceAgglomerate()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _faceAgglomerate faceAgglomerate

unset -f _financialFoam
_financialFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _financialFoam financialFoam

unset -f _fireFoam
_fireFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _fireFoam fireFoam

unset -f _fireToFoam
_fireToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -check -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _fireToFoam fireToFoam

unset -f _flattenMesh
_flattenMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _flattenMesh flattenMesh

unset -f _fluent3DMeshToFoam
_fluent3DMeshToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-cubit -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -ignoreCellGroups -ignoreFaceGroups -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _fluent3DMeshToFoam fluent3DMeshToFoam

unset -f _fluentMeshToFoam
_fluentMeshToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -writeSets -writeZones -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _fluentMeshToFoam fluentMeshToFoam

unset -f _foamDataToFluent
_foamDataToFluent()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-latestTime -newTimes -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamDataToFluent foamDataToFluent

unset -f _foamDictionary
_foamDictionary()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-disableFunctionEntries -expand -includes -keywords -noFunctionObjects -parallel -remove -value -srcDoc -doc -help "
    local optsWithArgs="-add -case -decomposeParDict -diff -entry -roots -set "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamDictionary foamDictionary

unset -f _foamFormatConvert
_foamFormatConvert()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -enableFunctionEntries -latestTime -newTimes -noConstant -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamFormatConvert foamFormatConvert

unset -f _foamHelp
_foamHelp()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamHelp foamHelp

unset -f _foamList
_foamList()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-compressibleTurbulenceModels -functionObjects -fvOptions -incompressibleTurbulenceModels -noFunctionObjects -registeredSwitches -switches -unset -srcDoc -doc -help "
    local optsWithArgs="-case -scalarBCs -vectorBCs "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamList foamList

unset -f _foamListTimes
_foamListTimes()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -processor -rm -withZero -srcDoc -doc -help "
    local optsWithArgs="-case -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamListTimes foamListTimes

unset -f _foamMeshToFluent
_foamMeshToFluent()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamMeshToFluent foamMeshToFluent

unset -f _foamToEnsight
_foamToEnsight()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -constant -deprecatedOrder -latestTime -newTimes -noFunctionObjects -noLagrangian -noPatches -noZero -nodeValues -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -cellZone -decomposeParDict -faceZones -fields -name -patches -region -roots -time -width "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToEnsight foamToEnsight

unset -f _foamToEnsightParts
_foamToEnsightParts()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -constant -latestTime -newTimes -noFunctionObjects -noLagrangian -noMesh -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -index -name -time -width "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToEnsightParts foamToEnsightParts

unset -f _foamToFireMesh
_foamToFireMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -constant -latestTime -newTimes -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -scale -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToFireMesh foamToFireMesh

unset -f _foamToGMV
_foamToGMV()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToGMV foamToGMV

unset -f _foamToStarMesh
_foamToStarMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noBnd -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -scale -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToStarMesh foamToStarMesh

unset -f _foamToSurface
_foamToSurface()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -tri -srcDoc -doc -help "
    local optsWithArgs="-case -scale -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToSurface foamToSurface

unset -f _foamToTetDualMesh
_foamToTetDualMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -noFunctionObjects -noZero -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToTetDualMesh foamToTetDualMesh

unset -f _foamToVTK
_foamToVTK()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-allPatches -ascii -constant -latestTime -nearCellValue -newTimes -noFaceZones -noFunctionObjects -noInternal -noLagrangian -noLinks -noPointValues -noZero -parallel -poly -surfaceFields -useTimeName -srcDoc -doc -help "
    local optsWithArgs="-case -cellSet -decomposeParDict -excludePatches -faceSet -fields -pointSet -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamToVTK foamToVTK

unset -f _foamUpgradeCyclics
_foamUpgradeCyclics()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -enableFunctionEntries -latestTime -newTimes -noFunctionObjects -noZero -parallel -test -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamUpgradeCyclics foamUpgradeCyclics

unset -f _foamyHexMesh
_foamyHexMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-checkGeometry -conformationOnly -noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamyHexMesh foamyHexMesh

unset -f _foamyQuadMesh
_foamyQuadMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case -pointsFile "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _foamyQuadMesh foamyQuadMesh

unset -f _gambitToFoam
_gambitToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _gambitToFoam gambitToFoam

unset -f _gmshToFoam
_gmshToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-keepOrientation -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -region "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _gmshToFoam gmshToFoam

unset -f _icoFoam
_icoFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _icoFoam icoFoam

unset -f _icoUncoupledKinematicParcelDyMFoam
_icoUncoupledKinematicParcelDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _icoUncoupledKinematicParcelDyMFoam icoUncoupledKinematicParcelDyMFoam

unset -f _icoUncoupledKinematicParcelFoam
_icoUncoupledKinematicParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _icoUncoupledKinematicParcelFoam icoUncoupledKinematicParcelFoam

unset -f _ideasUnvToFoam
_ideasUnvToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-dump -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _ideasUnvToFoam ideasUnvToFoam

unset -f _insideCells
_insideCells()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _insideCells insideCells

unset -f _interCondensatingEvaporatingFoam
_interCondensatingEvaporatingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _interCondensatingEvaporatingFoam interCondensatingEvaporatingFoam

unset -f _interDyMFoam
_interDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _interDyMFoam interDyMFoam

unset -f _interFoam
_interFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _interFoam interFoam

unset -f _interMixingFoam
_interMixingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _interMixingFoam interMixingFoam

unset -f _interPhaseChangeDyMFoam
_interPhaseChangeDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _interPhaseChangeDyMFoam interPhaseChangeDyMFoam

unset -f _interPhaseChangeFoam
_interPhaseChangeFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _interPhaseChangeFoam interPhaseChangeFoam

unset -f _kivaToFoam
_kivaToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -file -version -zHeadMin "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _kivaToFoam kivaToFoam

unset -f _laplacianFoam
_laplacianFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _laplacianFoam laplacianFoam

unset -f _magneticFoam
_magneticFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noB -noFunctionObjects -noH -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _magneticFoam magneticFoam

unset -f _mapFields
_mapFields()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-consistent -noFunctionObjects -parallelSource -parallelTarget -subtract -srcDoc -doc -help "
    local optsWithArgs="-case -mapMethod -sourceDecomposeParDict -sourceRegion -sourceTime -targetDecomposeParDict -targetRegion "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mapFields mapFields

unset -f _mapFieldsPar
_mapFieldsPar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-consistent -noFunctionObjects -noLagrangian -parallel -subtract -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -fields -mapMethod -patchMapMethod -roots -sourceRegion -sourceTime -targetRegion "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mapFieldsPar mapFieldsPar

unset -f _mdEquilibrationFoam
_mdEquilibrationFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mdEquilibrationFoam mdEquilibrationFoam

unset -f _mdFoam
_mdFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mdFoam mdFoam

unset -f _mdInitialise
_mdInitialise()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mdInitialise mdInitialise

unset -f _mergeMeshes
_mergeMeshes()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-addRegion -case -decomposeParDict -masterRegion -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mergeMeshes mergeMeshes

unset -f _mergeOrSplitBaffles
_mergeOrSplitBaffles()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-detectOnly -noFunctionObjects -overwrite -parallel -split -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mergeOrSplitBaffles mergeOrSplitBaffles

unset -f _mhdFoam
_mhdFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mhdFoam mhdFoam

unset -f _mirrorMesh
_mirrorMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mirrorMesh mirrorMesh

unset -f _mixtureAdiabaticFlameT
_mixtureAdiabaticFlameT()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mixtureAdiabaticFlameT mixtureAdiabaticFlameT

unset -f _modifyMesh
_modifyMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _modifyMesh modifyMesh

unset -f _moveDynamicMesh
_moveDynamicMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-checkAMI -noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _moveDynamicMesh moveDynamicMesh

unset -f _moveEngineMesh
_moveEngineMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _moveEngineMesh moveEngineMesh

unset -f _moveMesh
_moveMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _moveMesh moveMesh

unset -f _MPPICDyMFoam
_MPPICDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloudName -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _MPPICDyMFoam MPPICDyMFoam

unset -f _MPPICFoam
_MPPICFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _MPPICFoam MPPICFoam

unset -f _MPPICInterFoam
_MPPICInterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _MPPICInterFoam MPPICInterFoam

unset -f _mshToFoam
_mshToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-hex -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _mshToFoam mshToFoam

unset -f _multiphaseEulerFoam
_multiphaseEulerFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _multiphaseEulerFoam multiphaseEulerFoam

unset -f _multiphaseInterDyMFoam
_multiphaseInterDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _multiphaseInterDyMFoam multiphaseInterDyMFoam

unset -f _multiphaseInterFoam
_multiphaseInterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _multiphaseInterFoam multiphaseInterFoam

unset -f _netgenNeutralToFoam
_netgenNeutralToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _netgenNeutralToFoam netgenNeutralToFoam

unset -f _noise
_noise()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _noise noise

unset -f _nonNewtonianIcoFoam
_nonNewtonianIcoFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _nonNewtonianIcoFoam nonNewtonianIcoFoam

unset -f _objToVTK
_objToVTK()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _objToVTK objToVTK

unset -f _orientFaceZone
_orientFaceZone()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _orientFaceZone orientFaceZone

unset -f _particleTracks
_particleTracks()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _particleTracks particleTracks

unset -f _patchSummary
_patchSummary()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -expand -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _patchSummary patchSummary

unset -f _pdfPlot
_pdfPlot()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _pdfPlot pdfPlot

unset -f _PDRFoam
_PDRFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _PDRFoam PDRFoam

unset -f _PDRMesh
_PDRMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _PDRMesh PDRMesh

unset -f _pimpleDyMFoam
_pimpleDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _pimpleDyMFoam pimpleDyMFoam

unset -f _pimpleFoam
_pimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _pimpleFoam pimpleFoam

unset -f _pisoFoam
_pisoFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _pisoFoam pisoFoam

unset -f _plot3dToFoam
_plot3dToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noBlank -noFunctionObjects -singleBlock -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _plot3dToFoam plot3dToFoam

unset -f _polyDualMesh
_polyDualMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-concaveMultiCells -doNotPreserveFaceZones -noFunctionObjects -overwrite -splitAllFaces -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _polyDualMesh polyDualMesh

unset -f _porousSimpleFoam
_porousSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _porousSimpleFoam porousSimpleFoam

unset -f _postChannel
_postChannel()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _postChannel postChannel

unset -f _postProcess
_postProcess()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -list -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -field -fields -func -funcs -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _postProcess postProcess

unset -f _potentialFoam
_potentialFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-initialiseUBCs -noFunctionObjects -parallel -withFunctionObjects -writePhi -writep -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -pName -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _potentialFoam potentialFoam

unset -f _potentialFreeSurfaceDyMFoam
_potentialFreeSurfaceDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _potentialFreeSurfaceDyMFoam potentialFreeSurfaceDyMFoam

unset -f _potentialFreeSurfaceFoam
_potentialFreeSurfaceFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _potentialFreeSurfaceFoam potentialFreeSurfaceFoam

unset -f _reactingFoam
_reactingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reactingFoam reactingFoam

unset -f _reactingMultiphaseEulerFoam
_reactingMultiphaseEulerFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reactingMultiphaseEulerFoam reactingMultiphaseEulerFoam

unset -f _reactingParcelFilmFoam
_reactingParcelFilmFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reactingParcelFilmFoam reactingParcelFilmFoam

unset -f _reactingParcelFoam
_reactingParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reactingParcelFoam reactingParcelFoam

unset -f _reactingTwoPhaseEulerFoam
_reactingTwoPhaseEulerFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reactingTwoPhaseEulerFoam reactingTwoPhaseEulerFoam

unset -f _reconstructPar
_reconstructPar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-allRegions -constant -latestTime -newTimes -noFields -noFunctionObjects -noLagrangian -noSets -noZero -withZero -srcDoc -doc -help "
    local optsWithArgs="-case -fields -lagrangianFields -region -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reconstructPar reconstructPar

unset -f _reconstructParMesh
_reconstructParMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-cellDist -constant -fullMatch -latestTime -newTimes -noFunctionObjects -noZero -withZero -srcDoc -doc -help "
    local optsWithArgs="-case -mergeTol -region -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _reconstructParMesh reconstructParMesh

unset -f _redistributePar
_redistributePar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-cellDist -constant -decompose -latestTime -newTimes -noFunctionObjects -noZero -overwrite -parallel -reconstruct -withZero -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -mergeTol -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _redistributePar redistributePar

unset -f _refineHexMesh
_refineHexMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-minSet -noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _refineHexMesh refineHexMesh

unset -f _refinementLevel
_refinementLevel()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -readLevel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _refinementLevel refinementLevel

unset -f _refineMesh
_refineMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-all -noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _refineMesh refineMesh

unset -f _refineWallLayer
_refineWallLayer()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -useSet "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _refineWallLayer refineWallLayer

unset -f _removeFaces
_removeFaces()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _removeFaces removeFaces

unset -f _renumberMesh
_renumberMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -frontWidth -latestTime -noFunctionObjects -noZero -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _renumberMesh renumberMesh

unset -f _rhoCentralDyMFoam
_rhoCentralDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoCentralDyMFoam rhoCentralDyMFoam

unset -f _rhoCentralFoam
_rhoCentralFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoCentralFoam rhoCentralFoam

unset -f _rhoPimpleDyMFoam
_rhoPimpleDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoPimpleDyMFoam rhoPimpleDyMFoam

unset -f _rhoPimpleFoam
_rhoPimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoPimpleFoam rhoPimpleFoam

unset -f _rhoPorousSimpleFoam
_rhoPorousSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoPorousSimpleFoam rhoPorousSimpleFoam

unset -f _rhoReactingBuoyantFoam
_rhoReactingBuoyantFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoReactingBuoyantFoam rhoReactingBuoyantFoam

unset -f _rhoReactingFoam
_rhoReactingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoReactingFoam rhoReactingFoam

unset -f _rhoSimpleFoam
_rhoSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rhoSimpleFoam rhoSimpleFoam

unset -f _rotateMesh
_rotateMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _rotateMesh rotateMesh

unset -f _scalarTransportFoam
_scalarTransportFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _scalarTransportFoam scalarTransportFoam

unset -f _selectCells
_selectCells()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _selectCells selectCells

unset -f _setFields
_setFields()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _setFields setFields

unset -f _setSet
_setSet()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -loop -newTimes -noFunctionObjects -noSync -noVTK -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-batch -case -decomposeParDict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _setSet setSet

unset -f _setsToZones
_setsToZones()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFlipMap -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _setsToZones setsToZones

unset -f _shallowWaterFoam
_shallowWaterFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _shallowWaterFoam shallowWaterFoam

unset -f _simpleCoalParcelFoam
_simpleCoalParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _simpleCoalParcelFoam simpleCoalParcelFoam

unset -f _simpleFoam
_simpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _simpleFoam simpleFoam

unset -f _simpleReactingParcelFoam
_simpleReactingParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _simpleReactingParcelFoam simpleReactingParcelFoam

unset -f _singleCellMesh
_singleCellMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _singleCellMesh singleCellMesh

unset -f _smapToFoam
_smapToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _smapToFoam smapToFoam

unset -f _snappyHexMesh
_snappyHexMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-checkGeometry -noFunctionObjects -overwrite -parallel -profiling -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -outFile -patches -region -roots -surfaceSimplify "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _snappyHexMesh snappyHexMesh

unset -f _snappyRefineMesh
_snappyRefineMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _snappyRefineMesh snappyRefineMesh

unset -f _solidDisplacementFoam
_solidDisplacementFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _solidDisplacementFoam solidDisplacementFoam

unset -f _solidEquilibriumDisplacementFoam
_solidEquilibriumDisplacementFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _solidEquilibriumDisplacementFoam solidEquilibriumDisplacementFoam

unset -f _sonicDyMFoam
_sonicDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _sonicDyMFoam sonicDyMFoam

unset -f _sonicFoam
_sonicFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _sonicFoam sonicFoam

unset -f _sonicLiquidFoam
_sonicLiquidFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _sonicLiquidFoam sonicLiquidFoam

unset -f _splitCells
_splitCells()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-geometry -noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case -set -tol "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _splitCells splitCells

unset -f _splitMesh
_splitMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _splitMesh splitMesh

unset -f _splitMeshRegions
_splitMeshRegions()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-cellZones -cellZonesOnly -detectOnly -largestOnly -makeCellZones -noFunctionObjects -overwrite -parallel -prefixRegion -sloppyCellZones -useFaceZones -srcDoc -doc -help "
    local optsWithArgs="-blockedFaces -case -cellZonesFileOnly -decomposeParDict -insidePoint -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _splitMeshRegions splitMeshRegions

unset -f _sprayDyMFoam
_sprayDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _sprayDyMFoam sprayDyMFoam

unset -f _sprayEngineFoam
_sprayEngineFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _sprayEngineFoam sprayEngineFoam

unset -f _sprayFoam
_sprayFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _sprayFoam sprayFoam

unset -f _SRFPimpleFoam
_SRFPimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _SRFPimpleFoam SRFPimpleFoam

unset -f _SRFSimpleFoam
_SRFSimpleFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _SRFSimpleFoam SRFSimpleFoam

unset -f _star4ToFoam
_star4ToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-ascii -noFunctionObjects -solids -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _star4ToFoam star4ToFoam

unset -f _steadyParticleTracks
_steadyParticleTracks()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -srcDoc -doc -help "
    local optsWithArgs="-case -dict -region -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _steadyParticleTracks steadyParticleTracks

unset -f _stitchMesh
_stitchMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -partial -perfect -srcDoc -doc -help "
    local optsWithArgs="-case -region -toleranceDict "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _stitchMesh stitchMesh

unset -f _subsetMesh
_subsetMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -overwrite -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -patch -patches -region -resultTime -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _subsetMesh subsetMesh

unset -f _surfaceAdd
_surfaceAdd()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-mergeRegions -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -points "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceAdd surfaceAdd

unset -f _surfaceBooleanFeatures
_surfaceBooleanFeatures()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-invertedSpace -noFunctionObjects -perturb -surf1Baffle -surf2Baffle -srcDoc -doc -help "
    local optsWithArgs="-case -trim "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceBooleanFeatures surfaceBooleanFeatures

unset -f _surfaceCheck
_surfaceCheck()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-blockMesh -checkSelfIntersection -noFunctionObjects -splitNonManifold -verbose -srcDoc -doc -help "
    local optsWithArgs="-case -outputThreshold "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceCheck surfaceCheck

unset -f _surfaceClean
_surfaceClean()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noClean -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceClean surfaceClean

unset -f _surfaceCoarsen
_surfaceCoarsen()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceCoarsen surfaceCoarsen

unset -f _surfaceConvert
_surfaceConvert()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -group -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale -writePrecision "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceConvert surfaceConvert

unset -f _surfaceFeatureConvert
_surfaceFeatureConvert()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceFeatureConvert surfaceFeatureConvert

unset -f _surfaceFeatureExtract
_surfaceFeatureExtract()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-case -dict "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceFeatureExtract surfaceFeatureExtract

unset -f _surfaceFind
_surfaceFind()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -x -y -z "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceFind surfaceFind

unset -f _surfaceHookUp
_surfaceHookUp()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -dict "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceHookUp surfaceHookUp

unset -f _surfaceInertia
_surfaceInertia()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -shellProperties -srcDoc -doc -help "
    local optsWithArgs="-case -density -referencePoint "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceInertia surfaceInertia

unset -f _surfaceInflate
_surfaceInflate()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-checkSelfIntersection -debug -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -featureAngle -nSmooth "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceInflate surfaceInflate

unset -f _surfaceLambdaMuSmooth
_surfaceLambdaMuSmooth()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs="-featureFile "

    case ${prev} in

        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceLambdaMuSmooth surfaceLambdaMuSmooth

unset -f _surfaceMeshConvert
_surfaceMeshConvert()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -noFunctionObjects -tri -srcDoc -doc -help "
    local optsWithArgs="-case -dict -from -scaleIn -scaleOut -to "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceMeshConvert surfaceMeshConvert

unset -f _surfaceMeshConvertTesting
_surfaceMeshConvertTesting()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -noFunctionObjects -orient -stdout -surfMesh -testModify -triFace -triSurface -unsorted -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceMeshConvertTesting surfaceMeshConvertTesting

unset -f _surfaceMeshExport
_surfaceMeshExport()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -dict -from -name -scaleIn -scaleOut -to "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceMeshExport surfaceMeshExport

unset -f _surfaceMeshImport
_surfaceMeshImport()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-clean -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -dict -from -name -scaleIn -scaleOut -to "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceMeshImport surfaceMeshImport

unset -f _surfaceMeshInfo
_surfaceMeshInfo()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-areas -noFunctionObjects -xml -srcDoc -doc -help "
    local optsWithArgs="-case -scale "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceMeshInfo surfaceMeshInfo

unset -f _surfaceMeshTriangulate
_surfaceMeshTriangulate()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -excludeProcPatches -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -faceZones -patches -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceMeshTriangulate surfaceMeshTriangulate

unset -f _surfaceOrient
_surfaceOrient()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-inside -noFunctionObjects -usePierceTest -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceOrient surfaceOrient

unset -f _surfacePatch
_surfacePatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -dict "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfacePatch surfacePatch

unset -f _surfacePointMerge
_surfacePointMerge()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfacePointMerge surfacePointMerge

unset -f _surfaceRedistributePar
_surfaceRedistributePar()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-keepNonMapped -noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceRedistributePar surfaceRedistributePar

unset -f _surfaceRefineRedGreen
_surfaceRefineRedGreen()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceRefineRedGreen surfaceRefineRedGreen

unset -f _surfaceSplitByPatch
_surfaceSplitByPatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceSplitByPatch surfaceSplitByPatch

unset -f _surfaceSplitByTopology
_surfaceSplitByTopology()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-srcDoc -doc -help "
    local optsWithArgs=" "

    case ${prev} in

        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceSplitByTopology surfaceSplitByTopology

unset -f _surfaceSplitNonManifolds
_surfaceSplitNonManifolds()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-debug -noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceSplitNonManifolds surfaceSplitNonManifolds

unset -f _surfaceSubset
_surfaceSubset()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceSubset surfaceSubset

unset -f _surfaceToPatch
_surfaceToPatch()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -faceSet -tol "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceToPatch surfaceToPatch

unset -f _surfaceTransformPoints
_surfaceTransformPoints()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case -rollPitchYaw -rotate -scale -translate -yawPitchRoll "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _surfaceTransformPoints surfaceTransformPoints

unset -f _temporalInterpolate
_temporalInterpolate()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -divisions -fields -interpolationType -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _temporalInterpolate temporalInterpolate

unset -f _tetgenToFoam
_tetgenToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFaceFile -noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _tetgenToFoam tetgenToFoam

unset -f _thermoFoam
_thermoFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _thermoFoam thermoFoam

unset -f _topoSet
_topoSet()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noSync -noZero -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -dict -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _topoSet topoSet

unset -f _transformPoints
_transformPoints()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -rotateFields -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -rollPitchYaw -roots -rotate -scale -translate -yawPitchRoll "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _transformPoints transformPoints

unset -f _twoLiquidMixingFoam
_twoLiquidMixingFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _twoLiquidMixingFoam twoLiquidMixingFoam

unset -f _twoPhaseEulerFoam
_twoPhaseEulerFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _twoPhaseEulerFoam twoPhaseEulerFoam

unset -f _uncoupledKinematicParcelFoam
_uncoupledKinematicParcelFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -cloud -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _uncoupledKinematicParcelFoam uncoupledKinematicParcelFoam

unset -f _viewFactorsGen
_viewFactorsGen()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _viewFactorsGen viewFactorsGen

unset -f _vtkUnstructuredToFoam
_vtkUnstructuredToFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -srcDoc -doc -help "
    local optsWithArgs="-case "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _vtkUnstructuredToFoam vtkUnstructuredToFoam

unset -f _wallFunctionTable
_wallFunctionTable()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _wallFunctionTable wallFunctionTable

unset -f _writeMeshObj
_writeMeshObj()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-constant -latestTime -newTimes -noFunctionObjects -noZero -parallel -patchEdges -patchFaces -srcDoc -doc -help "
    local optsWithArgs="-case -cell -cellSet -decomposeParDict -face -faceSet -point -region -roots -time "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        -time)
            COMPREPLY=($(compgen -d -X '![-0-9]*' -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _writeMeshObj writeMeshObj

unset -f _XiDyMFoam
_XiDyMFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _XiDyMFoam XiDyMFoam

unset -f _XiFoam
_XiFoam()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -postProcess -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _XiFoam XiFoam

unset -f _zipUpMesh
_zipUpMesh()
{
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local opts="-noFunctionObjects -parallel -srcDoc -doc -help "
    local optsWithArgs="-case -decomposeParDict -region -roots "

    case ${prev} in
        -case)
            COMPREPLY=($(compgen -d -- ${cur}))
            ;;
        *Dict)
            COMPREPLY=($(compgen -f -- ${cur}))
            ;;
        -region)
            local regions=$(sed 's#/##g' <<< $([ -d system ] && (\cd system && (\ls -d */ 2>/dev/null))))
            COMPREPLY=($(compgen -W "$regions" -- ${cur}))
            ;;
        *)
            if [ "${optsWithArgs/${prev} /}" != "${optsWithArgs}" ]; then
                # Unknown what type of arg follows - set to files
                # not always correct but at least can still navigate path if
                # needed...
                COMPREPLY=($(compgen -f -- ${cur}))
            else
                # Catch-all - present all remaining options
                opts=$(_filter_opts "${opts}" "${COMP_LINE}")
                optsWithArgs=$(_filter_opts "${optsWithArgs}" "${COMP_LINE}")
                COMPREPLY=($(compgen -W "${opts} ${optsWithArgs}" -- ${cur}))
            fi
            ;;
    esac

    return 0
}
complete -o nospace -F _zipUpMesh zipUpMesh

